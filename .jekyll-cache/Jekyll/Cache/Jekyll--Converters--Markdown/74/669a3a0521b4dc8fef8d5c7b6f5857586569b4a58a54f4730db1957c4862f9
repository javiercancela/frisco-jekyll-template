I"è<p><strong><em>ClassCastException</em> o <em>instanceof</em></strong></p>

<p>Habitualmente se considera la instrucci√≥n <code class="language-plaintext highlighter-rouge">instanceof</code> como una forma muy poco √≥ptima de comprobar si una clase pertenece un objeto. Sin embargo, en <a href="http://www.blackberry.net/developers/javaknowledge/general/kpa0203185136.shtml" title="General Coding Tips">el portal de BlackBerry</a> aconsejan utilizar <code class="language-plaintext highlighter-rouge">instanceof</code> en vez de esperar a capturar una <code class="language-plaintext highlighter-rouge">ClassCastException</code> (lo cual es l√≥gico, ya que la excepci√≥n deber√≠a ser siempre m√°s costosa), debido a ciertas optimizaciones que se realizan cuando se hace el cast justo despu√©s de la comprobaci√≥n:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">if(x instanceof String) {&lt;br /&gt;
(String)x.whatever();&lt;br /&gt;
} else {&lt;br /&gt;
// something else&lt;br /&gt;
}</code></p>
</blockquote>

<p>Estas optimizaciones deber√≠an evitarnos tener que buscar m√©todos alternativos, como llamadas a m√©todos virtuales. Son optimizaciones comunes en las JVM de J2SE, pero que no s√© si se da en otras implementaciones de J2ME.</p>

<p><strong>Programaci√≥n orientada a objetos</strong></p>

<p>Sin entrar en debates acad√©micos sobre las ventajas e inconvenientes de la programaci√≥n orientada a objetos, hay que ser consciente de que algunas de las t√©cnicas de este paradigma son especialmente costosas para la m√°quina. Aunque programemos en Java, que es un lenguaje de clases y objetos, es conveniente ponerse a pensar de una forma m√°s estructurada, buscando ahorrar recursos a costa de incurrir en algunas cosas que nos ense√±aron a evitar cuando aprendimos POO. En concreto:</p>

<p>‚Äì Conviene minimizar el n√∫mero de clases. Ya no se trata de tener una clase para cada entidad que hayamos detectado en el an√°lisis. S√≥lo queremos las clases indispensables para dar un poco de sentido al c√≥digo, aunque los m√©todos que contengan no guarden mucha relaci√≥n entre s√≠. Este es el punto m√°s controvertido, ya que podemos limitarnos a meter todo el c√≥digo en una clase. Sin embargo no se trata de renunciar por completo al mecanismo de clases, tan solo de ser consciente de que estas tienen un coste importante.</p>

<p>‚Äì Como norma general, nada de <em>getters</em> y <em>setters</em>. La encapsulaci√≥n est√° bien para los PCs, no para los disposivitos m√≥viles. Unas variables miembro con √°mbito <em>protected</em> o <em>public</em> funcionar√°n mejor. El principal motivo para usar <em>getters</em> y <em>setter</em> es proporcionar una interfaz p√∫blica estable que nos permita cambiar la implementaci√≥n interna en el futuro. Salvo que queramos dise√±ar una librer√≠a p√∫blica o trabajemos en un proyecto realmente muy grande, no los necesitamos.</p>

<p>‚Äì Nada de crear interfaces. Est√°n muy bien para llevar a cabo una librer√≠a extensible, pero como en el punto anterior, es muy probable que no las necesitemos. Y en cuanto a su uso, cuantos menos interfaces implemente nuestra aplicaci√≥n, mejor. El ejemplo t√≠pico es la interfaz <code class="language-plaintext highlighter-rouge">CommandListener</code>: en vez de implementarla en cada pantalla, es m√°s efectivo implementarla en una sola clase controladora.</p>

<p>‚Äì Nada de clases abstractas. Ver punto anterior.</p>

<p>L√≥gicamente ninguna de estas recomendaciones se puede tomar como dogma, pero son √∫tiles para recordar que nuestra mentalidad de programador debe cambiar cuando nos enfrentemos a dispositivos m√≥viles.</p>

<h3 id="entradas-relacionadas">Entradas relacionadas:</h3>

<p><a href="/2007/12/07/consejos-para-programadores-j2me-y-blackberry-1/">Consejos para programadores J2ME (y BlackBerry) ‚Äì 1</a></p>

<p><a href="/2007/12/17/consejos-para-programadores-j2me-y-blackberry-2/">Consejos para programadores J2ME (y BlackBerry) ‚Äì 2</a></p>
:ET