I"ï<p>Bas√°ndome en <a href="http://www.blackberry.com/knowledgecenterpublic/livelink.exe/fetch/2000/348583/800451/800783/What_is_-_Programming_Tips-_General_Coding_Tips.html?nodeid=800465&amp;vernum=0" title="General Coding Tips">un documento</a> de la <em>Knowledge Base</em> de BlackBerry, que es aplicable a dispositivos J2ME en general, voy a exponer una serie de consejos b√°sicos para programadores Java que quieran comenzar a desarrollar en dispositivos m√≥viles.</p>

<p><strong>Bucles eficientes</strong></p>

<p>El desarrollo para dispositivos m√≥viles viene marcado por la preocupaci√≥n extrema (extrema para un programador acostumbrado a PCs y Macs) por el ahorro de recursos. Pese a que ahorrar recursos nunca es malo, en otras plataformas existen factores que suelen tener m√°s peso, como la claridad o econom√≠a del c√≥digo; en los dispositivos m√≥viles estos factores siempre van detr√°s del consumo de recursos. Un ejemplo:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">for(int i = 0; i &lt; vector.size(); i++) {&lt;br /&gt;
...&lt;br /&gt;
}</code></p>
</blockquote>

<p>Este c√≥digo nos permite ver en una sola l√≠nea que vamos a iterar sobre todos los elementos del objeto vector. Sin embargo no es √≥ptimo en t√©rminos de rendimiento:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">int vectorSize = vector.size();&lt;br /&gt;
for(int i = 0; i &lt; vectorSize; i++) {&lt;br /&gt;
...&lt;br /&gt;
}</code></p>
</blockquote>

<p>Invocar un m√©todo de un objeto en cada iteraci√≥n del bucle para obtener siempre el mismo resultado es ineficiente, pero con una simple l√≠nea m√°s de c√≥digo nos ahorramos un mont√≥n de instrucciones de procesador. De hecho, dado el poco esfuerzo que requiere yo dir√≠a que es tambi√©n una buena pr√°ctica para otras plataformas menos limitadas.</p>

<p>En el caso de no importar el orden de iteraci√≥n, una optimizaci√≥n adicional se consigue con:</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">for(int i = vector.size() - 1; i == 0; i--) {&lt;br /&gt;
...&lt;br /&gt;
}</code></p>
</blockquote>

<p>Como la asignaci√≥n inicial s√≥lo se realiza una vez nos ahorramos una variable local en la pila; y adem√°s la comparaci√≥n se realiza con el valor 0, que es la comparaci√≥n que m√°s r√°pidamente se realiza.</p>

<p>En el art√≠culo de la web de BlackBerry que mencion√© al principio se sugiere como optimizaci√≥n el cambio del post-incremento de i (i++) por un pre-incremento (++i) por ser este √∫ltimo m√°s r√°pido. Yo dudo de que esto sea cierto en este caso. El asunto es un tanto complejo, pero no he encontrado ning√∫n razonamiento que sustente esa afirmaci√≥n, y he encontrado este art√≠culo: <a href="http://www.ibm.com/developerworks/library/j-perf12053.html"><em>Eye on performance: Micro performance benchmarking</em></a> que parece respaldar lo contrario. Quiz√°s el origen de esta creencia est√° en C++, donde debido a la forma en la que se sobrecarga el operador ++, el pre-incremento y el post-incremento aplicados a objetos s√≠ presenta diferentes rendimientos.</p>

<p><strong>Entradas relacionadas:</strong></p>

<p><a href="/2007/10/25/introduccion-al-desarrollo-de-aplicaciones-para-telefonos-moviles-j2me-i/">Introducci√≥n al desarrollo de aplicaciones para tel√©fonos m√≥viles: J2ME (I)</a></p>

<p><a href="/2007/10/30/introduccion-al-desarrollo-de-aplicaciones-para-telefonos-moviles-j2me-y-ii/">Introducci√≥n al desarrollo de aplicaciones para tel√©fonos m√≥viles: J2ME (y II)</a></p>

<p><a href="/2007/11/05/introduccion-al-desarrollo-de-aplicaciones-para-telefonos-moviles-blackberry/">Introducci√≥n al desarrollo de aplicaciones para tel√©fonos m√≥viles: BlackBerry</a></p>
:ET